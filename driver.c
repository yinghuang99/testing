#include "utility.h"
#include "sensor.h"
#include "altimeter.h"
#include "base.h"


int main(int argc, char** argv)
{

	// one process will act as base and rest will act as sensor
	int BASE_RANK = 10;

	// default grid dimensions
	int GRID_DIMS_M = 3;
	int GRID_DIMS_N = 3;

	// to save the sensors count if it is not specified by user then default it 9
	int SENSORS_COUNT = 9;

	int num_proc, my_rank;

	// initilize MPI environement
	MPI_Init(&argc, &argv);

	// retrieve number of processes launched
	MPI_Comm_size(MPI_COMM_WORLD, &num_proc);


	// verify if grid dimensions are passed as commandline arguments, otherwise create 3x3 
	// default grid
	if (argc > 1)
	{

		// if user has passed the new dimensions as command line arguments then we will use
		// that dimensions
		GRID_DIMS_M = atoi(argv[1]);
		if (argc > 2)
		{
			GRID_DIMS_N = atoi(argv[2]);
		}
	}


	// Total number of sensor nodes in the grid
	SENSORS_COUNT = GRID_DIMS_M * GRID_DIMS_N;

	

	// if number of processes are not sufficient then terminate
	if (num_proc != SENSORS_COUNT + 1)
	{
		printf("Number of processes are not equal %d, cannot continue simulation\n", SENSORS_COUNT + 1);
		MPI_Finalize();
		return -1;
	}


	// last process will be treated as base station
	BASE_RANK = num_proc - 1;




	// obtain the rank of current process
	MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);

	// seed for random number generation, we will use as seed that changes everytime
	srand(time(NULL) + my_rank);



	double start_time = MPI_Wtime();

	// if it is last process then execute it as as base
	if (my_rank == BASE_RANK)
	{

		// sea heights which will be generated by altimeter

		// it will be shared among the base station and altimeter
		HeightValues* hvalues = malloc(sizeof(HeightValues) * SIZE_HValue);

		// current count of sea heights
		int count = 0;

		// if execution flag is true then altiemeter will continue execution,
		// otherwise it will stop
		bool execute_flag_alti = true;


		// launch an additional thread which will act as altimeter
		#pragma omp parallel num_threads(2)
		{
			if (omp_get_thread_num() == 0)
			{
				// base station execution
				executeBase(hvalues, &count, SENSORS_COUNT, GRID_DIMS_M, GRID_DIMS_N);
				execute_flag_alti = false;
			}

			// altimeter thread
			else
			{
				executeAltimeter(hvalues, &count, &execute_flag_alti, GRID_DIMS_M, GRID_DIMS_N);

			}
		}


		// compute the time taken to run the simulationn
		printf("Simulation time is %g secs\n", MPI_Wtime() - start_time);

		// deallocate all the memory of the altimeter values of heights
		free(hvalues);
	}
	else
	{

		// compute the adjacent nodes to current sensor
		int adjacent_up_rank = -1;
		int adjacent_down_rank = -1;
		int adjacent_left_rank = -1;
		int adjacent_right_rank = -1;
		int adjacents_count = 0;

		// get the position of current sensor in the grid i.e., (x, y) where x = i, y = j
		int i = my_rank / GRID_DIMS_N;
		int j = my_rank % GRID_DIMS_N;

		// if sensor has a left neighbour
		if (j > 0)
		{
			adjacent_left_rank = my_rank - 1;
			adjacents_count++;
		}

		// if sensor has a right neighbour
		if (j < (GRID_DIMS_N - 1))
		{
			adjacent_right_rank = my_rank + 1;
			adjacents_count++;
		}

		// if sensor has a up neighbour
		if (i > 0)
		{
			adjacent_up_rank = my_rank - GRID_DIMS_N;
			adjacents_count++;
		}

		// if sensor has a down neighbour
		if (i < (GRID_DIMS_M - 1))
		{
			adjacent_down_rank = my_rank + GRID_DIMS_N;
			adjacents_count++;
		}

		// printf("%d-----%d,%d,%d,%d\n", my_rank, adjacent_down_rank, adjacent_up_rank, adjacent_left_rank, adjacent_right_rank);


		// execute current sensor
		executeSensor(my_rank, adjacent_up_rank, adjacent_down_rank,
			adjacent_left_rank, adjacent_right_rank, BASE_RANK);
	}

	MPI_Finalize();
	return 0;
}